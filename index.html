<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>SKY | Best of Sandy and Kaiwen</title>
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600&display=swap" rel="stylesheet" />
	
		<!-- Firebase SDKs -->
		<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
		<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
		<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
	
		<style>
			:root {
				--pink-050: #fff5f8;
				--pink-100: #ffe4ec;
				--pink-200: #ffcadf;
				--pink-400: #ff90b2;
				--pink-600: #f45c87;
				--charcoal: #1f1a1c;
				--cloud: #fff9fb;
				--shadow-soft: 0 16px 45px rgba(244, 92, 135, 0.2);
			}

			* {
				box-sizing: border-box;
			}

			body {
				margin: 0;
				font-family: 'Fredoka', 'Poppins', sans-serif;
				background: radial-gradient(circle at top, var(--pink-050), #ffffff 45%, var(--pink-100));
				color: var(--charcoal);
				min-height: 100vh;
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 2rem;
			}

			body::before,
			body::after {
				content: '';
				position: fixed;
				width: 360px;
				height: 360px;
				background: rgba(255, 190, 213, 0.5);
				filter: blur(110px);
				z-index: 0;
			}

			body::before {
				top: -120px;
				left: -140px;
			}

			body::after {
				bottom: -120px;
				right: -140px;
			}

			.sr-only {
				position: absolute;
				width: 1px;
				height: 1px;
				padding: 0;
				margin: -1px;
				overflow: hidden;
				clip: rect(0, 0, 0, 0);
				white-space: nowrap;
				border: 0;
			}

			main {
				position: relative;
				z-index: 1;
				width: min(960px, 100%);
				background: rgba(255, 255, 255, 0.9);
				border-radius: 36px;
				box-shadow: var(--shadow-soft);
				overflow: hidden;
			}

			.step-card {
				display: none;
				padding: clamp(2rem, 5vw, 3.5rem);
				min-height: 520px;
				flex-direction: column;
				gap: 1.5rem;
			}

			.step-card.active {
				display: flex;
			}

			h1,
			h2,
			h3,
			h4 {
				margin: 0;
				color: var(--charcoal);
			}

			p {
				margin: 0;
				line-height: 1.6;
			}

			.eyebrow {
				text-transform: uppercase;
				letter-spacing: 0.2em;
				font-size: 0.85rem;
				color: var(--pink-600);
				font-weight: 600;
			}

			.name-form {
				display: flex;
				flex-wrap: wrap;
				gap: 1rem;
				align-items: center;
			}

			.text-input {
				flex: 1 1 240px;
				padding: 1rem 1.25rem;
				border-radius: 999px;
				border: 2px solid var(--pink-200);
				background: var(--cloud);
				font-size: 1rem;
				transition: border 0.2s ease, box-shadow 0.2s ease;
			}

			.text-input:focus {
				outline: none;
				border-color: var(--pink-600);
				box-shadow: 0 0 0 4px rgba(244, 92, 135, 0.1);
			}

			.btn {
				border: none;
				border-radius: 999px;
				padding: 0.95rem 1.75rem;
				font-size: 1rem;
				font-weight: 600;
				cursor: pointer;
				transition: transform 0.18s ease, box-shadow 0.18s ease;
				box-shadow: 0 10px 25px rgba(244, 92, 135, 0.25);
			}

			.btn:active {
				transform: scale(0.92);
			}

			.btn-primary {
				background: linear-gradient(120deg, var(--pink-600), var(--pink-400));
				color: #fff;
			}

			.btn-ghost {
				background: rgba(244, 92, 135, 0.1);
				color: var(--pink-600);
				box-shadow: none;
			}

			.hint-box {
				min-height: 54px;
				border-radius: 20px;
				padding: 1rem 1.5rem;
				background: rgba(255, 202, 223, 0.4);
				color: var(--charcoal);
				font-weight: 500;
				opacity: 0;
				transform: translateY(10px);
				transition: opacity 0.2s ease, transform 0.2s ease;
			}

			.hint-box.visible {
				opacity: 1;
				transform: translateY(0);
			}

			.shake {
				animation: shake 0.45s ease;
			}

			@keyframes shake {
				0%, 100% {
					transform: translateX(0);
				}
				20%, 60% {
					transform: translateX(-8px);
				}
				40%, 80% {
					transform: translateX(8px);
				}
			}

			.traits-shell {
				display: flex;
				flex-direction: column;
				gap: 1.5rem;
			}

			.traits-box {
				background: var(--pink-050);
				border-radius: 28px;
				padding: 1.5rem;
				max-height: 380px;
				overflow-y: auto;
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
				gap: 0.75rem;
			}

			.traits-box::-webkit-scrollbar {
				width: 6px;
			}

			.traits-box::-webkit-scrollbar-thumb {
				background: var(--pink-400);
				border-radius: 999px;
			}

			.trait-btn {
				border-radius: 30px;
				border: 2px solid rgba(244, 92, 135, 0.35);
				padding: 0.85rem 1rem;
				background: #fff;
				color: var(--charcoal);
				font-weight: 500;
				cursor: pointer;
				transition: transform 0.2s ease, border 0.2s ease, background 0.2s ease, color 0.2s ease;
			}

			.trait-btn:active {
				transform: scale(0.93);
			}

			.trait-btn.good-selected {
				background: linear-gradient(120deg, #8be4a6, #4ccf87);
				border-color: #4ccf87;
				color: #0f3b25;
				box-shadow: 0 10px 25px rgba(76, 207, 135, 0.4);
				cursor: default;
			}

			.trait-btn.locked {
				pointer-events: none;
			}

			.trait-btn.bad-alert {
				background: #ffd5d5;
				border-color: #ff7a7a;
				color: #a80032;
				animation: wobble 0.6s ease;
			}

			@keyframes wobble {
				0% {
					transform: translateX(0);
				}
				25% {
					transform: translateX(-6px) rotate(-1deg);
				}
				50% {
					transform: translateX(6px) rotate(1deg);
				}
				100% {
					transform: translateX(0);
				}
			}

			.trait-counter {
				font-size: 1.15rem;
				font-weight: 600;
				color: var(--pink-600);
			}

			.success-note {
				min-height: 24px;
				font-size: 0.95rem;
				color: var(--charcoal);
			}

			.final-hero {
				display: flex;
				flex-direction: column;
				gap: 1.25rem;
				text-align: center;
			}

			.timer-card {
				background: var(--pink-050);
				border-radius: 32px;
				padding: 1.5rem;
				box-shadow: inset 0 0 0 2px rgba(244, 92, 135, 0.08);
			}

			.timer-grid {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
				gap: 1rem;
			}

			.timer-piece {
				background: #fff;
				border-radius: 24px;
				padding: 1rem;
				box-shadow: var(--shadow-soft);
				text-align: center;
			}

			.timer-value {
				font-size: 2rem;
				font-weight: 600;
			}

			.timeline {
				display: flex;
				flex-direction: column;
				gap: 1.25rem;
			}

			.timeline-header h3 {
				margin-bottom: 0.25rem;
			}

			.timeline-note {
				font-size: 0.9rem;
				color: rgba(31, 26, 28, 0.7);
			}

			.timeline-controls {
				display: flex;
				flex-wrap: wrap;
				align-items: center;
				gap: 1rem;
				justify-content: space-between;
			}

			.year-selector {
				display: flex;
				flex-wrap: wrap;
				gap: 0.5rem;
			}

			.year-pill {
				border: 2px solid rgba(244, 92, 135, 0.35);
				border-radius: 999px;
				padding: 0.35rem 0.9rem;
				background: #fff;
				font-weight: 600;
				color: var(--charcoal);
				cursor: pointer;
				transition: all 0.2s ease;
			}

			.year-pill.active {
				background: var(--pink-600);
				color: #fff;
				box-shadow: 0 0.5rem 1.5rem rgba(244, 92, 135, 0.35);
				border-color: transparent;
			}

			#timeline-range-label {
				font-size: 0.95rem;
				color: rgba(31, 26, 28, 0.9);
			}

			.timeline-track {
				position: relative;
				background: #fff;
				border-radius: 32px;
				padding: 2rem 3rem;
				min-height: 1000px;
				box-shadow: 0 20px 40px rgba(31, 26, 28, 0.08);
				overflow: hidden;
			}

			.timeline-axis {
				position: absolute;
				left: 50%;
				top: 2rem;
				bottom: 2rem;
				width: 4px;
				background: rgba(244, 92, 135, 0.25);
				transform: translateX(-50%);
			}

			.timeline-intervals,
			.timeline-events {
				position: absolute;
				top: 2rem;
				bottom: 2rem;
				left: 0;
				right: 0;
				pointer-events: none;
			}

			.interval-marker {
				position: absolute;
				left: 50%;
				transform: translate(-50%, -50%);
				text-align: center;
			}

			.interval-marker::before {
				content: '';
				display: block;
				width: 14px;
				height: 14px;
				border-radius: 999px;
				margin: 0 auto 0.2rem;
				background: rgba(244, 92, 135, 0.2);
			}

			.interval-marker.month-start::before {
				background: var(--pink-600);
			}

			.interval-label {
				font-size: 0.8rem;
				font-weight: 600;
				color: rgba(31, 26, 28, 0.8);
			}

			.timeline-event {
				position: absolute;
				left: calc(50% + 30px);
				transform: translateY(-50%);
				display: flex;
				align-items: center;
				gap: 0.5rem;
				pointer-events: auto;
				cursor: pointer;
				transition: transform 0.2s ease;
			}

			.timeline-event.left {
				left: auto;
				right: calc(50% + 30px);
				flex-direction: row-reverse;
			}

			.timeline-event:hover {
				transform: translateY(-50%) scale(1.05);
			}

			.timeline-event-dot {
				width: 16px;
				height: 16px;
				border-radius: 999px;
				background: var(--pink-600);
				box-shadow: 0 0 0 6px rgba(244, 92, 135, 0.15);
				transition: all 0.2s ease;
			}

			.timeline-event:hover .timeline-event-dot {
				box-shadow: 0 0 0 10px rgba(244, 92, 135, 0.25);
			}

			.timeline-event-title {
				font-weight: 600;
				background: var(--pink-050);
				padding: 0.4rem 0.75rem;
				border-radius: 999px;
				box-shadow: 0 10px 20px rgba(244, 92, 135, 0.12);
			}

			.event-form {
				display: grid;
				gap: 1rem;
				background: rgba(255, 255, 255, 0.85);
				padding: 1.5rem;
				border-radius: 28px;
				box-shadow: inset 0 0 0 2px rgba(244, 92, 135, 0.08);
				transition: box-shadow 0.3s ease, background 0.3s ease;
			}

			.event-form.flash-edit {
				animation: flashBorder 0.6s ease;
			}

			@keyframes flashBorder {
				0%, 100% {
					box-shadow: inset 0 0 0 2px rgba(244, 92, 135, 0.08);
					background: rgba(255, 255, 255, 0.85);
				}
				50% {
					box-shadow: inset 0 0 0 3px rgba(59, 130, 246, 0.4);
					background: rgba(59, 130, 246, 0.05);
				}
			}

			.event-form-row {
				display: flex;
				flex-direction: column;
				gap: 0.3rem;
			}

			.event-form label {
				font-weight: 600;
			}

			.event-form input,
			.event-form textarea {
				border-radius: 18px;
				border: 2px solid rgba(244, 92, 135, 0.35);
				padding: 0.85rem 1rem;
				font-family: inherit;
				font-size: 1rem;
				background: #fff;
			}

			.event-form textarea {
				min-height: 90px;
				resize: vertical;
			}

			.event-form input[type='file'] {
				padding: 0.6rem 1rem;
			}

			.timeline-form-note {
				font-size: 0.85rem;
				color: rgba(31, 26, 28, 0.7);
			}

			.timeline-message {
				min-height: 24px;
				font-size: 0.95rem;
				font-weight: 600;
				color: var(--pink-600);
			}

			.form-button-group {
				display: flex;
				gap: 0.75rem;
				flex-wrap: wrap;
			}

			.btn-cancel {
				background: rgba(107, 114, 128, 0.12);
				color: #4b5563;
				border: none;
				padding: 0.85rem 1.75rem;
				border-radius: 999px;
				font-weight: 700;
				font-size: 1rem;
				cursor: pointer;
				transition: all 0.2s ease;
				font-family: inherit;
			}

			.btn-cancel:hover {
				background: rgba(107, 114, 128, 0.25);
				transform: translateY(-2px);
			}

			.event-list {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
				gap: 1rem;
			}

			.event-card {
				background: #fff;
				border-radius: 24px;
				padding: 1rem;
				box-shadow: 0 20px 30px rgba(31, 26, 28, 0.08);
				display: flex;
				flex-direction: column;
				gap: 0.75rem;
			}

			.event-card img {
				width: 100%;
				border-radius: 18px;
				object-fit: contain;
				max-height: 300px;
			}

			.event-meta {
				font-size: 0.9rem;
				color: rgba(31, 26, 28, 0.7);
			}

			.event-actions {
				display: flex;
				gap: 0.5rem;
				flex-wrap: wrap;
			}

			.event-delete,
			.event-edit {
				border: none;
				padding: 0.5rem 0.9rem;
				border-radius: 999px;
				font-weight: 600;
				cursor: pointer;
				transition: background 0.2s ease;
				font-size: 0.9rem;
			}

			.event-delete {
				background: rgba(244, 92, 135, 0.12);
				color: var(--pink-600);
			}

			.event-delete:hover {
				background: rgba(244, 92, 135, 0.25);
			}

			.event-edit {
				background: rgba(59, 130, 246, 0.12);
				color: #3b82f6;
			}

			.event-edit:hover {
				background: rgba(59, 130, 246, 0.25);
			}

			.timeline-empty {
				background: rgba(255, 255, 255, 0.9);
				padding: 1rem;
				border-radius: 18px;
				text-align: center;
				color: rgba(31, 26, 28, 0.7);
			}

			.event-detail-modal {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(31, 26, 28, 0.75);
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 1000;
				padding: 2rem;
				opacity: 0;
				transition: opacity 0.3s ease;
			}

			.event-detail-modal.active {
				display: flex;
				opacity: 1;
			}

			.event-detail-content {
				background: #fff;
				border-radius: 32px;
				padding: 2rem;
				max-width: 560px;
				width: 100%;
				max-height: 80vh;
				overflow-y: auto;
				box-shadow: 0 30px 60px rgba(31, 26, 28, 0.2);
				position: relative;
				transform: scale(0.9);
				transition: transform 0.3s ease;
			}

			.event-detail-modal.active .event-detail-content {
				transform: scale(1);
			}

			.event-detail-close {
				position: absolute;
				top: 1.5rem;
				right: 1.5rem;
				background: rgba(244, 92, 135, 0.12);
				border: none;
				width: 36px;
				height: 36px;
				border-radius: 999px;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 1.5rem;
				color: var(--pink-600);
				transition: background 0.2s ease, transform 0.2s ease;
			}

			.event-detail-close:hover {
				background: rgba(244, 92, 135, 0.25);
				transform: scale(1.1);
			}

			.event-detail-header {
				display: flex;
				flex-direction: column;
				gap: 0.5rem;
				margin-bottom: 1.5rem;
			}

			.event-detail-header h3 {
				margin: 0;
				color: var(--charcoal);
				font-size: 1.75rem;
			}

			.event-detail-date {
				font-size: 0.95rem;
				color: rgba(31, 26, 28, 0.7);
				font-weight: 600;
			}

			.event-detail-body {
				display: flex;
				flex-direction: column;
				gap: 1.25rem;
			}

			.event-detail-photo {
				width: 100%;
				border-radius: 24px;
				object-fit: contain;
				max-height: 500px;
			}

			.event-detail-description {
				line-height: 1.6;
				color: var(--charcoal);
			}

			.event-detail-actions {
				display: flex;
				gap: 0.75rem;
				margin-top: 1rem;
			}

			.event-detail-delete,
			.event-detail-edit {
				border: none;
				padding: 0.75rem 1.25rem;
				border-radius: 999px;
				font-weight: 600;
				cursor: pointer;
				transition: background 0.2s ease;
				font-size: 1rem;
			}

			.event-detail-delete {
				background: rgba(244, 92, 135, 0.12);
				color: var(--pink-600);
			}

			.event-detail-delete:hover {
				background: rgba(244, 92, 135, 0.25);
			}

			.event-detail-edit {
				background: rgba(59, 130, 246, 0.12);
				color: #3b82f6;
			}

			.event-detail-edit:hover {
				background: rgba(59, 130, 246, 0.25);
			}

			@media (max-width: 640px) {
				.step-card {
					padding: 2rem 1.5rem;
				}
				.name-form {
					flex-direction: column;
				}
				.text-input {
					width: 100%;
				}
			}
		</style>
	</head>
	<body>
		<main>
			<section id="intro-step" class="step-card active" aria-live="polite">
				<div>
					<p class="eyebrow">welcome</p>
					<h1>Please enter the passcode to enter site</h1>
					<p>Only the right person knows</p>
				</div>
				<form class="name-form" id="name-form">
					<label class="sr-only" for="secret-input">Hidden prompt</label>
					<input id="secret-input" class="text-input" type="text" placeholder="pound your keys here" autocomplete="off" />
					<button class="btn btn-primary" type="submit">Enter</button>
				</form>
				<div id="hint-box" class="hint-box" role="status" aria-live="assertive"></div>
			</section>

			<section id="traits-step" class="step-card" aria-live="polite">
				<div>
					<p class="eyebrow">checkpoint 2</p>
					<h2>But do you know Sandy's best traits?</h2>
					<p class="trait-counter" id="trait-counter">0 / 10 selected</p>
					<p class="success-note" id="trait-success"></p>
				</div>
				<div class="traits-shell">
					<p>Tap through the list.</p>
					<div class="traits-box" id="traits-box"></div>
				</div>
			</section>

			<section id="main-step" class="step-card" aria-live="polite">
				<div class="final-hero">
					<p class="eyebrow">Home</p>
					<h2>SKY · Best of Sandy &amp; Kaiwen</h2>
					<p>Since November 27, 2024 · 4:23 PM PDT</p>
				</div>
				<div class="timer-card">
					<div class="timer-grid">
						<div class="timer-piece">
							<div class="timer-value" id="timer-years">0</div>
							<div>years</div>
						</div>
						<div class="timer-piece">
							<div class="timer-value" id="timer-days">0</div>
							<div>days</div>
						</div>
						<div class="timer-piece">
							<div class="timer-value" id="timer-hours">0</div>
							<div>hours</div>
						</div>
						<div class="timer-piece">
							<div class="timer-value" id="timer-minutes">0</div>
							<div>minutes</div>
						</div>
						<div class="timer-piece">
							<div class="timer-value" id="timer-seconds">0</div>
							<div>seconds</div>
						</div>
					</div>
				</div>
				<div class="timeline">
					<div class="timeline-header">
						<h3>Living timeline</h3>
						<p class="timeline-note">Vertical memories from day one. Pick a year, drop up to 4 highlights per month, and they'll stay saved in this browser.</p>
					</div>
					<div class="timeline-controls">
						<div class="year-selector" id="year-selector"></div>
						<span id="timeline-range-label"></span>
					</div>
					<div class="timeline-track">
						<div class="timeline-axis"></div>
						<div class="timeline-intervals" id="timeline-intervals"></div>
						<div class="timeline-events" id="timeline-events"></div>
					</div>
					<p class="timeline-message" id="timeline-message"></p>
					<form class="event-form" id="event-form">
						<div class="event-form-row">
							<label for="event-date">Date *</label>
							<input type="date" id="event-date" name="event-date" required min="2024-10-01" max="" />
						</div>
						<div class="event-form-row">
							<label for="event-title">Title *</label>
							<input type="text" id="event-title" name="event-title" placeholder="ex. Firefly picnic" required />
						</div>
						<div class="event-form-row">
							<label for="event-description">Description</label>
							<textarea id="event-description" name="event-description" placeholder="What made it unforgettable?"></textarea>
						</div>
						<div class="event-form-row">
							<label for="event-photo">Photo (optional)</label>
							<input type="file" id="event-photo" name="event-photo" accept="image/*" />
							<p class="timeline-form-note">Photos are stored locally so they never leave this device.</p>
						</div>
						<div class="form-button-group">
							<button class="btn btn-primary" type="submit">Save memory</button>
							<button class="btn-cancel" type="button" id="cancel-edit-btn" style="display: none;">Cancel</button>
						</div>
					</form>
					<div class="event-list" id="event-list"></div>
				</div>
			</section>
		</main>

		<div id="event-detail-modal" class="event-detail-modal">
			<div class="event-detail-content">
				<button class="event-detail-close" type="button" id="event-detail-close" aria-label="Close">×</button>
				<div class="event-detail-header">
					<h3 id="event-detail-title"></h3>
					<p class="event-detail-date" id="event-detail-date"></p>
				</div>
				<div class="event-detail-body" id="event-detail-body"></div>
			</div>
		</div>

		<script>
			// Firebase Configuration
			const firebaseConfig = {
				apiKey: "AIzaSyDfWvOp1DD6SvrrH_yGbvT_0U4YBZY5eck",
				authDomain: "sky-website-acdc8.firebaseapp.com",
				projectId: "sky-website-acdc8",
				storageBucket: "sky-website-acdc8.firebasestorage.app",
				messagingSenderId: "340999562676",
				appId: "1:340999562676:web:2c18cd72bbf681daee7ee1",
				measurementId: "G-QPFG6MCDWF"
			};

			// Initialize Firebase
			let db = null;
			let storage = null;
			let firebaseInitialized = false;

			try {
				firebase.initializeApp(firebaseConfig);
				db = firebase.firestore();
				storage = firebase.storage();
				firebaseInitialized = true;
				console.log('Firebase initialized successfully');
			} catch (error) {
				console.warn('Firebase initialization failed, falling back to localStorage:', error);
				firebaseInitialized = false;
			}

			const steps = ['intro-step', 'traits-step', 'main-step'];

			function showStep(id) {
				steps.forEach((stepId) => {
					const el = document.getElementById(stepId);
					if (!el) return;
					el.classList.toggle('active', stepId === id);
				});
				window.scrollTo({ top: 0, behavior: 'smooth' });
			}

			const secretName = 'sandy kang';
			const secretPassword1 = '0212'; // Secret password to skip directly to home
			const secretPassword2 = 'ajumma';
			const hints = [
				"Look at the website name!",
				"Queen of morning coffees and matcha lattes.",
				"Think of the person whose laugh amplifies every room.",
				"Rhymes with 'candy', because she is sweeter.",
				"Starts with the letter just after R.",
				"Engraved on in a certain someone's heart;)",
				"hmm maybe you just aren't the right person",
				"don't think too hard",
				"#8^!nz7%)}~#!4+o?"
			];
			let remainingHints = [...hints];

			const nameForm = document.getElementById('name-form');
			const secretInput = document.getElementById('secret-input');
			const hintBox = document.getElementById('hint-box');

			const revealHint = () => {
				if (!remainingHints.length) {
					hintBox.textContent = 'No more hints. You already know this!';
					hintBox.classList.add('visible', 'shake');
					setTimeout(() => hintBox.classList.remove('shake'), 500);
					return;
				}
				const randomIndex = Math.floor(Math.random() * remainingHints.length);
				const hint = remainingHints.splice(randomIndex, 1)[0];
				hintBox.textContent = hint;
				hintBox.classList.add('visible', 'shake');
				setTimeout(() => hintBox.classList.remove('shake'), 500);
			};

			nameForm.addEventListener('submit', (event) => {
				event.preventDefault();
				const guess = secretInput.value.trim().toLowerCase();
				if (!guess) {
					return;
				}
				if (guess === secretPassword1 || guess === secretPassword2) {
					hintBox.textContent = 'Fast pass activated! ';
					hintBox.classList.add('visible');
					secretInput.value = '';
					setTimeout(() => showStep('main-step'), 900);
				} else if (guess === secretName) {
					hintBox.textContent = 'Welcome home, Sandy Kang! ';
					hintBox.classList.add('visible');
					secretInput.value = '';
					setTimeout(() => showStep('traits-step'), 900);
				} else {
					revealHint();
				}
			});

			setTimeout(() => secretInput.focus(), 600);

			const traits = [
				{ label: 'Brightest smile', type: 'good' },
				{ label: 'Caring listener', type: 'good' },
				{ label: 'Adventure buddy', type: 'good' },
				{ label: 'Matcha connoisseur', type: 'good' },
				{ label: 'Smarty pants', type: 'good' },
				{ label: 'Hour glass;)', type: 'good' },
				{ label: 'Homework procrastinator', type: 'bad' },
				{ label: 'Ajumma', type: 'good' },
				{ label: 'Annoyed shopper', type: 'bad' },
				{ label: 'Warmest hugs', type: 'good' },
				{ label: 'Plant whisperer', type: 'good' },
				{ label: 'Vocal legend', type: 'good' },
				{ label: 'Terrible at texting back', type: 'bad' },
				{ label: 'Sleeping Buddy', type: 'good' },
				{ label: 'Background movie gremlin', type: 'bad' },
				{ label: 'Determined squirrelly', type: 'good' },
				{ label: 'Genuinely genuine', type: 'good' },
				{ label: 'Shockingly good dancer', type: 'good' }
			];

			const traitsBox = document.getElementById('traits-box');
			const traitCounter = document.getElementById('trait-counter');
			const traitSuccess = document.getElementById('trait-success');
			const goal = 10;
			let goodSelections = 0;

			traits.forEach((trait) => {
				const btn = document.createElement('button');
				btn.type = 'button';
				btn.textContent = trait.label;
				btn.className = 'trait-btn';
				btn.dataset.traitType = trait.type;
				btn.addEventListener('click', () => {
					if (trait.type === 'good') {
						if (btn.classList.contains('locked')) return;
						btn.classList.add('good-selected', 'locked');
						goodSelections += 1;
						traitCounter.textContent = `${goodSelections} / ${goal} selected`;
						if (goodSelections >= goal) {
							traitSuccess.textContent = 'That was too ez. Welcome!';
							setTimeout(() => showStep('main-step'), 1300);
						}
					} else {
						btn.classList.add('bad-alert');
						setTimeout(() => btn.classList.remove('bad-alert'), 600);
					}
				});
				traitsBox.appendChild(btn);
			});

			const relationshipStart = new Date('2024-11-27T16:23:00-08:00');
			const timerEls = {
				years: document.getElementById('timer-years'),
				days: document.getElementById('timer-days'),
				hours: document.getElementById('timer-hours'),
				minutes: document.getElementById('timer-minutes'),
				seconds: document.getElementById('timer-seconds')
			};

			const updateTimer = () => {
				const now = new Date();
				let diff = now - relationshipStart;
				if (diff < 0) diff = 0;
				const seconds = Math.floor(diff / 1000);
				const totalDays = Math.floor(seconds / 86400);
				const years = Math.floor(totalDays / 365);
				const days = totalDays % 365;
				const hours = Math.floor((seconds % 86400) / 3600);
				const minutes = Math.floor((seconds % 3600) / 60);
				const remainingSeconds = seconds % 60;
				timerEls.years.textContent = years;
				timerEls.days.textContent = days;
				timerEls.hours.textContent = String(hours).padStart(2, '0');
				timerEls.minutes.textContent = String(minutes).padStart(2, '0');
				timerEls.seconds.textContent = String(remainingSeconds).padStart(2, '0');
			};

			updateTimer();
			setInterval(updateTimer, 1000);

			const timelineEls = {
				yearSelector: document.getElementById('year-selector'),
				rangeLabel: document.getElementById('timeline-range-label'),
				intervals: document.getElementById('timeline-intervals'),
				events: document.getElementById('timeline-events'),
				message: document.getElementById('timeline-message'),
				form: document.getElementById('event-form'),
				eventList: document.getElementById('event-list'),
				eventDate: document.getElementById('event-date'),
				eventTitle: document.getElementById('event-title'),
				eventDescription: document.getElementById('event-description'),
				eventPhoto: document.getElementById('event-photo')
			};

			const timelineStartDate = (() => {
				const base = new Date('2024-10-01T12:00:00-07:00');
				base.setHours(0, 0, 0, 0);
				return base;
			})();
			const today = (() => {
				const now = new Date();
				now.setHours(0, 0, 0, 0);
				return now;
			})();
			const timelineStorageKey = 'skyTimelineEvents.v1';
			const startYear = timelineStartDate.getFullYear();
			const todayYear = today.getFullYear();
			let timelineEvents = [];
			let currentTimelineYear = todayYear;
			let editingEventId = null; // Track which event is being edited

			const setTimelineMessage = (text = '') => {
				if (timelineEls.message) {
					timelineEls.message.textContent = text;
				}
			};

			const normalizeDate = (date) => {
				const normalized = new Date(date);
				normalized.setHours(0, 0, 0, 0);
				return normalized;
			};

			const formatDisplayDate = (date, options = { month: 'short', day: 'numeric', year: 'numeric' }) =>
				date.toLocaleString(undefined, options);

			const formatRangeLabel = (start, end) => `${formatDisplayDate(start)} → ${formatDisplayDate(end)}`;

			const formatInputDate = (date) => date.toISOString().split('T')[0];

			const loadTimelineEvents = async () => {
				if (!firebaseInitialized || !db) {
					try {
						const raw = JSON.parse(localStorage.getItem(timelineStorageKey)) || [];
						return raw.filter((evt) => evt && evt.date && evt.title);
					} catch (error) {
						console.warn('Unable to load timeline events from localStorage', error);
						setTimelineMessage('Timeline data could not be loaded.');
						return [];
					}
				}

				try {
					const snapshot = await db.collection('timeline-events').orderBy('date').get();
					const events = [];
					snapshot.forEach((doc) => {
						events.push({ id: doc.id, ...doc.data() });
					});
					console.log(`Loaded ${events.length} events from Firestore`);
					return events;
				} catch (error) {
					console.warn('Unable to load from Firestore, falling back to localStorage:', error);
					try {
						const raw = JSON.parse(localStorage.getItem(timelineStorageKey)) || [];
						return raw.filter((evt) => evt && evt.date && evt.title);
					} catch (localError) {
						console.warn('LocalStorage also failed:', localError);
						return [];
					}
				}
			};

			const saveTimelineEvents = async () => {
				if (!firebaseInitialized || !db) {
					try {
						localStorage.setItem(timelineStorageKey, JSON.stringify(timelineEvents));
					} catch (error) {
						console.warn('Unable to save timeline events to localStorage', error);
						setTimelineMessage('Memories could not be saved.');
					}
					return;
				}

				try {
					const batch = db.batch();
					timelineEvents.forEach((evt) => {
						const docRef = db.collection('timeline-events').doc(evt.id);
						batch.set(docRef, {
							date: evt.date,
							title: evt.title,
							description: evt.description || '',
							photo: evt.photo || null
						});
					});
					await batch.commit();
					console.log('Events saved to Firestore');
					try {
						localStorage.setItem(timelineStorageKey, JSON.stringify(timelineEvents));
					} catch (e) {
						console.warn('LocalStorage backup failed:', e);
					}
				} catch (error) {
					console.warn('Unable to save to Firestore, saving to localStorage:', error);
					try {
						localStorage.setItem(timelineStorageKey, JSON.stringify(timelineEvents));
					} catch (localError) {
						console.warn('LocalStorage also failed:', localError);
						setTimelineMessage('Memories could not be saved.');
					}
				}
			};

			const deleteEventFromFirestore = async (eventId) => {
				if (!firebaseInitialized || !db) return;
				try {
					await db.collection('timeline-events').doc(eventId).delete();
					console.log('Event deleted from Firestore');
				} catch (error) {
					console.warn('Unable to delete from Firestore:', error);
				}
			};

			const getYearBounds = (year) => {
				const start = year === startYear ? new Date(timelineStartDate) : new Date(year, 0, 1);
				const endCandidate = year === todayYear ? today : new Date(year, 11, 31);
				return {
					start,
					end: endCandidate
				};
			};

			const getYearList = () => {
				let latestYear = todayYear;
				timelineEvents.forEach((evt) => {
					const year = new Date(evt.date).getFullYear();
					if (!Number.isNaN(year)) {
						latestYear = Math.max(latestYear, year);
					}
				});
				const years = [];
				for (let year = startYear; year <= latestYear; year += 1) {
					years.push(year);
				}
				return years;
			};

			const dateToPercent = (date, start, end) => {
				const total = end - start;
				if (total <= 0) {
					return 0;
				}
				const diff = date - start;
				return Math.min(100, Math.max(0, (diff / total) * 100));
			};

			const generateMarkers = (year) => {
				const markers = [];
				const { start, end } = getYearBounds(year);
				markers.push({
					date: new Date(start),
					isMonthStart: start.getDate() === 1,
					label: start.getDate() === 1 ? formatDisplayDate(start, { month: 'short' }) : formatDisplayDate(start, { month: 'short', day: 'numeric' })
				});

				let monthCursor = new Date(start.getFullYear(), start.getMonth(), 1);
				if (monthCursor < start) {
					monthCursor = new Date(start.getFullYear(), start.getMonth() + 1, 1);
				}

				while (monthCursor <= end) {
					markers.push({
						date: new Date(monthCursor),
						isMonthStart: true,
						label: formatDisplayDate(monthCursor, { month: 'short' })
					});
					const mid = new Date(monthCursor.getFullYear(), monthCursor.getMonth(), 16);
					if (mid >= start && mid <= end) {
						markers.push({ date: mid, isMonthStart: false });
					}
					monthCursor = new Date(monthCursor.getFullYear(), monthCursor.getMonth() + 1, 1);
				}

				if (markers[markers.length - 1].date.getTime() !== end.getTime()) {
					markers.push({
						date: new Date(end),
						isMonthStart: end.getDate() === 1,
						label: end.getDate() === 1 ? formatDisplayDate(end, { month: 'short' }) : formatDisplayDate(end, { month: 'short', day: 'numeric' })
					});
				}

				return markers.sort((a, b) => a.date - b.date);
			};

			const renderYearSelector = () => {
				if (!timelineEls.yearSelector) return;
				const years = getYearList();
				if (!years.includes(currentTimelineYear)) {
					currentTimelineYear = years[years.length - 1];
				}
				timelineEls.yearSelector.innerHTML = '';
				years.forEach((year) => {
					const pill = document.createElement('button');
					pill.type = 'button';
					pill.className = `year-pill${year === currentTimelineYear ? ' active' : ''}`;
					pill.textContent = year;
					pill.addEventListener('click', () => {
						currentTimelineYear = year;
						renderTimeline();
					});
					timelineEls.yearSelector.appendChild(pill);
				});
			};

			const renderEventList = (yearEvents) => {
				if (!timelineEls.eventList) return;
				timelineEls.eventList.innerHTML = '';
				if (!yearEvents.length) {
					const emptyState = document.createElement('div');
					emptyState.className = 'timeline-empty';
					emptyState.textContent = 'No memories saved for this year yet. Add one above!';
					timelineEls.eventList.appendChild(emptyState);
					return;
				}

				yearEvents.forEach((evt) => {
					const card = document.createElement('article');
					card.className = 'event-card';
					const title = document.createElement('h4');
					title.textContent = evt.title;
					const meta = document.createElement('p');
					meta.className = 'event-meta';
					meta.textContent = formatDisplayDate(new Date(evt.date));
					card.append(title, meta);
					if (evt.photo) {
						const img = document.createElement('img');
						img.src = evt.photo;
						img.alt = `${evt.title} photo`;
						card.appendChild(img);
					}
					if (evt.description) {
						const desc = document.createElement('p');
						desc.textContent = evt.description;
						card.appendChild(desc);
					}
					const actionsDiv = document.createElement('div');
					actionsDiv.className = 'event-actions';
					const editBtn = document.createElement('button');
					editBtn.type = 'button';
					editBtn.className = 'event-edit';
					editBtn.textContent = 'Edit';
					editBtn.addEventListener('click', () => {
						if (confirm('Do you want to edit this memory?')) {
							populateFormForEdit(evt);
						}
					});
					const deleteBtn = document.createElement('button');
					deleteBtn.type = 'button';
					deleteBtn.className = 'event-delete';
					deleteBtn.textContent = 'Delete';
					deleteBtn.addEventListener('click', async () => {
						if (confirm('Are you sure you want to delete this memory? This cannot be undone.')) {
							await deleteEventFromFirestore(evt.id);
							timelineEvents = timelineEvents.filter((item) => item.id !== evt.id);
							await saveTimelineEvents();
							setTimelineMessage('Memory deleted.');
							renderTimeline();
						}
					});
					actionsDiv.appendChild(editBtn);
					actionsDiv.appendChild(deleteBtn);
					card.appendChild(actionsDiv);
					timelineEls.eventList.appendChild(card);
				});
			};

			const renderTimeline = () => {
				if (!timelineEls.intervals || !timelineEls.events) return;
				renderYearSelector();
				const { start, end } = getYearBounds(currentTimelineYear);
				if (timelineEls.rangeLabel) {
					timelineEls.rangeLabel.textContent = formatRangeLabel(start, end);
				}
				timelineEls.intervals.innerHTML = '';
				timelineEls.events.innerHTML = '';
				const markers = generateMarkers(currentTimelineYear);
				markers.forEach((marker) => {
					const markerEl = document.createElement('div');
					markerEl.className = `interval-marker${marker.isMonthStart ? ' month-start' : ''}`;
					markerEl.style.top = `${dateToPercent(marker.date, start, end)}%`;
					if (marker.isMonthStart && marker.label) {
						const label = document.createElement('div');
						label.className = 'interval-label';
						label.textContent = marker.label;
						markerEl.appendChild(label);
					}
					timelineEls.intervals.appendChild(markerEl);
				});

				const yearEvents = timelineEvents
					.filter((evt) => new Date(evt.date).getFullYear() === currentTimelineYear)
					.sort((a, b) => new Date(a.date) - new Date(b.date));

				const overlapThreshold = 8; // % distance to consider events too close
				let lastPosition = -999;
				let lastSide = 'right';

				yearEvents.forEach((evt) => {
					const date = new Date(evt.date);
					if (date < start || date > end) {
						return;
					}
					const eventEl = document.createElement('div');
					const position = dateToPercent(date, start, end);
					
					// Determine if this event is too close to the previous one
					const isOverlapping = Math.abs(position - lastPosition) < overlapThreshold;
					const side = isOverlapping ? (lastSide === 'right' ? 'left' : 'right') : 'right';
					
					eventEl.className = side === 'left' ? 'timeline-event left' : 'timeline-event';
					eventEl.style.top = `${position}%`;
					eventEl.title = evt.description ? `${evt.title}: ${evt.description}` : evt.title;
					eventEl.addEventListener('click', () => showEventModal(evt));
					const dot = document.createElement('span');
					dot.className = 'timeline-event-dot';
					const title = document.createElement('span');
					title.className = 'timeline-event-title';
					title.textContent = evt.title;
					eventEl.append(dot, title);
					timelineEls.events.appendChild(eventEl);
					
					lastPosition = position;
					lastSide = side;
				});

				renderEventList(yearEvents);
			};

			const readFileAsDataUrl = (file) =>
				new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onload = () => resolve(reader.result);
					reader.onerror = () => reject(new Error('File reading failed'));
					reader.readAsDataURL(file);
				});

			const getMonthCount = (dateObj, excludeId = null) => {
				const targetYear = dateObj.getFullYear();
				const targetMonth = dateObj.getMonth();
				return timelineEvents.filter((evt) => {
					if (excludeId && evt.id === excludeId) return false;
					const evtDate = new Date(evt.date);
					return evtDate.getFullYear() === targetYear && evtDate.getMonth() === targetMonth;
				}).length;
			};

			const populateFormForEdit = (evt) => {
				if (!timelineEls.eventDate || !timelineEls.eventTitle) return;
				editingEventId = evt.id;
				timelineEls.eventDate.value = evt.date;
				timelineEls.eventTitle.value = evt.title;
				if (timelineEls.eventDescription) {
					timelineEls.eventDescription.value = evt.description || '';
				}
				const submitBtn = timelineEls.form.querySelector('button[type="submit"]');
				if (submitBtn) {
					submitBtn.textContent = 'Update memory';
				}
				const cancelBtn = document.getElementById('cancel-edit-btn');
				if (cancelBtn) {
					cancelBtn.style.display = 'block';
				}
				// Flash the form to indicate edit mode
				if (timelineEls.form) {
					timelineEls.form.classList.add('flash-edit');
					setTimeout(() => {
						timelineEls.form.classList.remove('flash-edit');
					}, 600);
				}
				setTimelineMessage('Editing mode: Update the fields and save.');
				timelineEls.eventTitle.focus();
				timelineEls.eventTitle.scrollIntoView({ behavior: 'smooth', block: 'center' });
			};

			const cancelEdit = () => {
				editingEventId = null;
				if (timelineEls.form) {
					timelineEls.form.reset();
					if (timelineEls.eventDate) {
						timelineEls.eventDate.value = formatInputDate(today);
					}
				}
				const submitBtn = timelineEls.form?.querySelector('button[type="submit"]');
				if (submitBtn) {
					submitBtn.textContent = 'Save memory';
				}
				const cancelBtn = document.getElementById('cancel-edit-btn');
				if (cancelBtn) {
					cancelBtn.style.display = 'none';
				}
				setTimelineMessage('');
			};

			const handleEventSubmit = async (event) => {
				event.preventDefault();
				if (!timelineEls.eventDate || !timelineEls.eventTitle) return;
				const dateValue = timelineEls.eventDate.value;
				const titleValue = timelineEls.eventTitle.value.trim();
				const descriptionValue = (timelineEls.eventDescription?.value || '').trim();
				if (!dateValue || !titleValue) {
					setTimelineMessage('Date and title are required.');
					return;
				}
				const entryDate = normalizeDate(dateValue);
				if (entryDate < timelineStartDate) {
					setTimelineMessage('Memories begin on Oct 1, 2024.');
					return;
				}
				if (entryDate > today) {
					setTimelineMessage('We can only log moments that already happened.');
					return;
				}

				// Check if editing
				if (editingEventId) {
					// Editing mode
					if (getMonthCount(entryDate, editingEventId) >= 4) {
						setTimelineMessage('Only 4 memories per month are allowed.');
						return;
					}

					const existingEvent = timelineEvents.find((evt) => evt.id === editingEventId);
					if (!existingEvent) {
						setTimelineMessage('Event not found.');
						cancelEdit();
						return;
					}

					const finalizeUpdate = async (photoData) => {
						existingEvent.date = dateValue;
						existingEvent.title = titleValue;
						existingEvent.description = descriptionValue;
						if (photoData) {
							existingEvent.photo = photoData;
						}
						
						// Save the updated event individually to Firestore if Firebase is initialized
						if (firebaseInitialized && db) {
							try {
								const docRef = db.collection('timeline-events').doc(existingEvent.id);
								await docRef.set({
									date: existingEvent.date,
									title: existingEvent.title,
									description: existingEvent.description || '',
									photo: existingEvent.photo || null
								});
								console.log('Event updated in Firestore');
							} catch (error) {
								console.warn('Unable to update event in Firestore:', error);
							}
						}
						
						// Also update localStorage
						try {
							localStorage.setItem(timelineStorageKey, JSON.stringify(timelineEvents));
						} catch (e) {
							console.warn('LocalStorage save failed:', e);
						}
						
						currentTimelineYear = new Date(existingEvent.date).getFullYear();
						renderTimeline();
						setTimelineMessage('Memory updated!');
						cancelEdit();
					};

					const photoFile = timelineEls.eventPhoto?.files?.[0];
					if (photoFile) {
						try {
							const dataUrl = await readFileAsDataUrl(photoFile);
							await finalizeUpdate(dataUrl);
						} catch (error) {
							console.warn('Photo upload failed', error);
							setTimelineMessage('Photo could not be read. Try a smaller image.');
						}
					} else {
						await finalizeUpdate(null);
					}
				} else {
					// Create mode
					if (getMonthCount(entryDate) >= 4) {
						setTimelineMessage('Only 4 memories per month are allowed.');
						return;
					}

					const newEvent = {
						id:
							typeof crypto !== 'undefined' && crypto.randomUUID
								? crypto.randomUUID()
								: `evt-${Date.now()}-${Math.random().toString(16).slice(2)}`,
						date: dateValue,
						title: titleValue,
						description: descriptionValue,
						photo: null
					};

					const finalizeSave = async (photoData) => {
						newEvent.photo = photoData || null;
						timelineEvents.push(newEvent);
						
						// Save the new event individually to Firestore if Firebase is initialized
						if (firebaseInitialized && db) {
							try {
								const docRef = db.collection('timeline-events').doc(newEvent.id);
								await docRef.set({
									date: newEvent.date,
									title: newEvent.title,
									description: newEvent.description || '',
									photo: newEvent.photo || null
								});
								console.log('New event saved to Firestore');
							} catch (error) {
								console.warn('Unable to save new event to Firestore:', error);
							}
						}
						
						// Also update localStorage
						try {
							localStorage.setItem(timelineStorageKey, JSON.stringify(timelineEvents));
						} catch (e) {
							console.warn('LocalStorage save failed:', e);
						}
						
						currentTimelineYear = new Date(newEvent.date).getFullYear();
						renderTimeline();
						setTimelineMessage('Memory saved!');
						timelineEls.form.reset();
						timelineEls.eventDate.value = dateValue;
					};

					const photoFile = timelineEls.eventPhoto?.files?.[0];
					if (photoFile) {
						try {
							const dataUrl = await readFileAsDataUrl(photoFile);
							await finalizeSave(dataUrl);
						} catch (error) {
							console.warn('Photo upload failed', error);
							setTimelineMessage('Photo could not be read. Try a smaller image.');
						}
					} else {
						await finalizeSave(null);
					}
				}
			};

			const modalEls = {
				modal: document.getElementById('event-detail-modal'),
				title: document.getElementById('event-detail-title'),
				date: document.getElementById('event-detail-date'),
				body: document.getElementById('event-detail-body'),
				close: document.getElementById('event-detail-close')
			};

			const showEventModal = (evt) => {
				if (!modalEls.modal || !modalEls.title || !modalEls.date || !modalEls.body) return;
				modalEls.title.textContent = evt.title;
				modalEls.date.textContent = formatDisplayDate(new Date(evt.date));
				modalEls.body.innerHTML = '';
				if (evt.photo) {
					const img = document.createElement('img');
					img.src = evt.photo;
					img.alt = `${evt.title} photo`;
					img.className = 'event-detail-photo';
					modalEls.body.appendChild(img);
				}
				if (evt.description) {
					const desc = document.createElement('p');
					desc.className = 'event-detail-description';
					desc.textContent = evt.description;
					modalEls.body.appendChild(desc);
				}
				const actions = document.createElement('div');
				actions.className = 'event-detail-actions';
				const editBtn = document.createElement('button');
				editBtn.type = 'button';
				editBtn.className = 'event-detail-edit';
				editBtn.textContent = 'Edit memory';
				editBtn.addEventListener('click', () => {
					if (confirm('Do you want to edit this memory?')) {
						hideEventModal();
						populateFormForEdit(evt);
					}
				});
				const deleteBtn = document.createElement('button');
				deleteBtn.type = 'button';
				deleteBtn.className = 'event-detail-delete';
				deleteBtn.textContent = 'Delete memory';
				deleteBtn.addEventListener('click', async () => {
					if (confirm('Are you sure you want to delete this memory? This cannot be undone.')) {
						await deleteEventFromFirestore(evt.id);
						timelineEvents = timelineEvents.filter((item) => item.id !== evt.id);
						await saveTimelineEvents();
						hideEventModal();
						setTimelineMessage('Memory deleted.');
						renderTimeline();
					}
				});
				actions.appendChild(editBtn);
				actions.appendChild(deleteBtn);
				modalEls.body.appendChild(actions);
				modalEls.modal.classList.add('active');
				document.body.style.overflow = 'hidden';
			};

			const hideEventModal = () => {
				if (modalEls.modal) {
					modalEls.modal.classList.remove('active');
					document.body.style.overflow = '';
				}
			};

			if (modalEls.close) {
				modalEls.close.addEventListener('click', hideEventModal);
			}

			if (modalEls.modal) {
				modalEls.modal.addEventListener('click', (e) => {
					if (e.target === modalEls.modal) {
						hideEventModal();
					}
				});
			}

			const initTimeline = async () => {
				if (!timelineEls.form) return;
				timelineEvents = await loadTimelineEvents();
				currentTimelineYear = Math.max(startYear, Math.min(todayYear, currentTimelineYear));
				if (timelineEls.eventDate) {
					timelineEls.eventDate.max = formatInputDate(today);
					if (!timelineEls.eventDate.value) {
						timelineEls.eventDate.value = formatInputDate(today);
					}
				}
				renderTimeline();
				timelineEls.form.addEventListener('submit', handleEventSubmit);
				
				// Wire up cancel button
				const cancelBtn = document.getElementById('cancel-edit-btn');
				if (cancelBtn) {
					cancelBtn.addEventListener('click', cancelEdit);
				}
			};

			initTimeline();
		</script>
	</body>
</html>